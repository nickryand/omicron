:showtitle:
:toc: left
:icons: font

= Running Omicron on a bench gimlet (Non-Simulated)

These instructions are intended to run Omicron on a gimlet on a bench, which is
an actual gimlet, but with nothing other than power connected to the backplane.

In examples used here, we had two K.2 cards each with a network connection to a
different network.  This is not a requirement for running a bench gimlet.  Some
examples will be different depending on if you have one or two network interfaces.

If you're okay with the omicron ip pools (both internal services & instances)
existing on the same L2 segment with the network used to access the gimlet, then
just one NIC is fine.  That's basically the setup described in the main how-to-run doc.

In our examples, one network will be used for connecting to the host OS running
on the gimlet, and the second network will be used for connecting to Nexus as well
as allow instances running on Omicron to connect to the outside.

Whatever network you plan on using for the gimlet, you will need a contiguous
range of IP addresses.  This range will be split into two segments. One segment
will be for internal services, the other for external.  The required minimum
number of IPs for each segment is decided by requirements in Omicron, and the
values here may be out of date.

== Overview

For setting up a build system, follow the instructions in
xref:how-to-run.adoc[How to Run].

You will need to compile Omicron somewhere else, then copy the files over
to the gimlet.

== Gimlet setup

You gimlet should have the M.2 devices formatted and setup with 4k sector
sizes.  Info on how to do that is:  <TBD>

== A helios image for your bench gimlet

To run Omicron, you require a helios image on your gimlet constructed with
some required libraries.  If your gimlet is lacking these, you will need to
make and install a special build on your gimlet.
To do that:
Clone the helios repo: https://github.com/oxidecomputer/helios.git
Check the helios repo README, as things may have changed.

First, run gmake setup:
[source,text]
----
cd helios
gmake setup
----

Once that finishes, you are ready to build your helios image.  Below is an
example command used to build the image for gimlet-sn21.

The optional `-P` argument arranges for anything in that directory to be laid
on top of the base image, which we presently use to, say, add in the
sled-agent SMF manifest and binaries etc.  For example if you `mkdir /tmp/proto`
and create `/tmp/proto/usr/bin/blah` then passing the `-P /tmp/proto` to your
build command would make `/tmp/proto/usr/bin/blah` appear in the image at
`/usr/bin/blah`

You should update `-N` (name of your image) and `-o` (output location of build
files) for your setup and needs.

[source,text]
----
ds=$(TZ=US/Pacific date +%Y%m%d-%H%M%S)
./helios-build experiment-image \
  -N "gimlet-sn21-$ds" \
  -p helios-netdev=https://pkg.oxide.computer/helios-netdev \
  -o "/net/catacomb/data/staff/dock/gimlet-sn21/os-$ds" \
  -F optever=0.23 \
  -B \
  -P alanproto
----

The `-F optever=0.23` is subject to change.
Once this image is built, you must install it on your gimlet.

== Building Omicron for a bench gimlet

To build Omicron for bench-gimlets, custom modifications to the source are
required (till we make a better solution)

In the sled-hardware/src/underlay.rs file,
Change the function to always take the `Ok(XDE_VNIC_NAMES..` path, this basically
short circuits the code that will return `cxgbe#` on a real gimlet, which we
don't want in this case.

[source,text]
----
pub fn find_chelsio_links() -> Result<Vec<PhysicalLink>, Error> {
    /*
    if is_gimlet().map_err(Error::SystemDetection)? {
        Dladm::list_physical().map_err(Error::FindLinks).map(|links| {
            links
                .into_iter()
                .filter(|link| link.0.starts_with(CHELSIO_LINK_PREFIX))
                .collect()
        })
    } else {
        */
    Ok(XDE_VNIC_NAMES
        .into_iter()
        .map(|name| PhysicalLink(name.to_string()))
        .collect())
    // }
}
----

Then, build your omicron repo:
[source,text]
----
cargo build --release
----

=== Gimet non-gimlet configuration changes

These changes are how we tell Nexus/Omicron what IP addresses it will use
for internal services that require external network access, and what addresses
we use for ingress and egress of network traffic from virtual machines we
create.

Update these sections of `smf/sled-agent/non-gimlet/config-rss.toml` with
the appropriate network information.  These values are for gimlet-sn21

Choose two IP Addresses from the `internal_services_ip_pool_ranges`

[source,text]
----
external_dns_ips = [ "172.20.24.20", "172.20.24.21" ]
----

Select a range of address that includes at least 10.
This number is subject to change depending on what Omicron needs.
[source,text]
----
[[internal_services_ip_pool_ranges]]
first = "172.20.24.11"          <--- first address of pool used for internal services (like Nexus)
last = "172.20.24.22"           <--- last address of pool used for internal services
----

And this section as well
[source,text]
----
# Configuration to bring up boundary services and make nexus reachable from the outside
[rack_network_config]
gateway_ip = "172.20.24.1"    <--- ip address of your default gateway / router
infra_ip_first = "172.20.24.23" <--- first address of pool used for rack networking
                                     this typically starts where the
                                     internal_services_ip_pool_ranges ends.
infra_ip_last = "172.20.24.50"  <--- last address of pool used for rack networking
uplink_port = "qsfp0"           <--- for "softnpu" environments, this will always be "qsfp0"
uplink_port_speed = "1G"       <--- uplink interface speed
uplink_port_fec="none"
uplink_ip = "172.20.24.23"      <--- address to assign to the uplink port. I just chose
                                     the first IP in the infra_ip_ list
----

Update this section of your `smf/sled-agent/non-gimlet/config.toml` if you are using
a second k.2 for your Omicron/Nexus network.  If you have only one, then you don't
need to update this section.
[source,text]
----
# An optional data link from which we extract a MAC address.
# This is used as a unique identifier for the bootstrap address.
#
# If empty, this will be equivalent to the first result from:
# $ dladm show-phys -p -o LINK
data_link = "rge1"
----

Next, setup your omicron package target.  I'm using the name "sn21" for my target:
[source,text]
----
./target/release/omicron-package -t sn21 target create -i standard -m non-gimlet -s softnpu
----

Then make the packages:
[source,text]
----
./target/release/omicron-package --target sn21 package
----

Once completed, copy these files over to the gimlet:
[source,text]
----
rsync --delete -Paz tools out \
  ./target/release/omicron-package package-manifest.toml \
  --exclude /out/downloads \
  --exclude *.p5p \
  root@gimlet-sn21:/tmp/omicron
----

This includes the `tools` directory as we make use of a few scripts.

== On the gimlet.

After copying your Omicron packages over, setup the system with "virtual hardware".
In my example, the `rge1` is the network interface the gimlet will be using for
Omicron/Nexus.  If you only have one K.2, then you don't need the `PHYSICAL_LINK..`
All commands on the gimlet are run as root.

[source,text]
----
cd /tmp
PHYSICAL_LINK=rge1 ./tools/create_virtual_hardware.sh
----

== Install Omicron
Next, we install Omicron

[source,console]
----
cd /tmp
./omicron-package -t sn21 install
----

You should start seeing zones appear, and you can monitor the sled-agent log
for progress with `tail -f $(svcs -L sled-agent)`.  It will take a few seconds
for the sled-agent service to start.

Watch for the oxz_switch zone to appear, and give it an additional minute
to come online.  Then, run this command to setup softnpu.
The GATEWAY_IP is the I.P. address of the gateway for the network we are
using for Omicron/Nexus.  This will be the same as what you set in the
config-rss.toml file.
The GATEWAY_MAC is the mac address of the gateway.
If you are only using one network for both the gimlet and Omicron/Nexus, then
you don't have to set either of these, as the `softnpu-init.sh` script will
figure out what the correct values are.

[source,console]
----
export GATEWAY_IP=172.20.24.1
export GATEWAY_MAC=aa:0:4:0:ca:fe
tools/scrimlet/softnpu-init.sh
----

=== Additional configuration after starting Omicron

Internal services that require external connectivity (e.g. Nexus, Boundary NTP,
External DNS) do so via OPTE. When using SoftNPU we'll need to configure Proxy ARP for
the services IP Pool.  Use the values from the [internal_services_ip_pool_ranges]
section of the config-rss.toml you setup above, specifically
SERVICE_IP_POOL_START is [[internal_services_ip_pool_ranges]] first
SERVICE_IP_POOL_END   is [[internal_services_ip_pool_ranges]] last

The SOFTNPU_MAC value should be the same as the example below, as that mac
is created as part of the `softnpu-init.sh` script.

[source,console]
----
# dladm won't return leading zeroes but `scadm` expects them
# Look at your `dladm show-vnic sc0_1 -p -o macaddress` output, get the mac
# address and add any leading zeros to octets that require it.

export SOFTNPU_MAC=a8:e1:de:01:70:1d

/opt/oxide/softnpu/stuff/scadm \
  --server /opt/oxide/softnpu/stuff/server \
  --client /opt/oxide/softnpu/stuff/client \
  standalone \
  add-proxy-arp \
  $SERVICE_IP_POOL_START \
  $SERVICE_IP_POOL_END \
  $SOFTNPU_MAC
----

You'll also need to configure Proxy ARP.
The ip pool start and ip pool end also come from your config-rss.toml
`IP_POOL_START` is [rack_network_config] infra_ip_first
`IP_POOL_END`   is [rack_network_config] infra_ip_last
[source,console]
----
export SOFTNPU_MAC=a8:e1:de:01:70:1d

/opt/oxide/softnpu/stuff/scadm \
  --server /opt/oxide/softnpu/stuff/server \
  --client /opt/oxide/softnpu/stuff/client \
  standalone \
  add-proxy-arp \
  $IP_POOL_START \
  $IP_POOL_END \
  $SOFTNPU_MAC
----

== Wait for Nexus

The final step is to wait for all zones to start and Nexus to come online.
When it does, you should be able to see a login page in an address from the
range you specified in `[internal_services_ip_pool_ranges]`.  Typically
the second or third address is where nexus will land.
For gimlet-sn21 this was: http://172.20.24.12/
