// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

//! Property based test for bootstore scheme v0 protocol logic
//!
//! This test creates a single `Fsm` as the system under test (SUT), where that
//! FSM is a learner node.

mod common;

use assert_matches::assert_matches;
use bootstore::schemes::v0::{
    create_pkgs, ApiError, ApiOutput, Config, Envelope, Fsm, LearnedSharePkg,
    Msg, MsgError, RackUuid, Request, RequestType, Response, ResponseType,
    SharePkg, State,
};
use bootstore::trust_quorum::RackSecret;
use proptest::prelude::*;
use secrecy::ExposeSecret;
use sled_hardware::Baseboard;
use std::collections::BTreeSet;
use std::time::Instant;
use uuid::Uuid;

use common::generators::{
    arb_config, arb_initial_member_ids, arb_learner_id, MAX_INITIAL_MEMBERS,
    MIN_INITIAL_MEMBERS, TICK_TIMEOUT,
};

/// Actions run during the learning phase of the test
#[derive(Debug, Clone)]
pub enum LearnAction {
    Timeout(Baseboard),
    CannotSpareAShare(Baseboard),
    Success(Baseboard),
}

#[derive(Debug, Clone)]
pub struct TestInput {
    pub sut_id: Baseboard,
    pub initial_members: BTreeSet<Baseboard>,
    pub config: Config,
    pub rack_uuid: RackUuid,
    pub learn_sequence: Vec<LearnAction>,
}

/// We randomize the order of learners, and only allow one node to distribute
/// shares, thus ensuring that the learner itself will rotate and exercise the
/// full learning path.
fn arb_learn_sequence(
    initial_members: BTreeSet<Baseboard>,
) -> impl Strategy<Value = Vec<LearnAction>> {
    // The peer that successfully responds to the learner
    let peers: Vec<_> = initial_members.iter().cloned().collect();
    (
        any::<prop::sample::Index>(),
        any::<prop::sample::Index>(),
        Just(peers).prop_shuffle(),
    )
        .prop_map(|(success_index, timeout_index, peers)| {
            let success_index = success_index.index(peers.len());
            let timeout_index = timeout_index.index(peers.len());
            let mut seq = vec![];
            for (i, peer) in peers.into_iter().enumerate() {
                if i == success_index {
                    seq.push(LearnAction::Success(peer));
                    break;
                } else if i >= timeout_index {
                    seq.push(LearnAction::Timeout(peer));
                } else {
                    seq.push(LearnAction::CannotSpareAShare(peer));
                }
            }
            seq
        })
}

/// Create the input to this test
fn arb_test_input() -> impl Strategy<Value = TestInput> {
    arb_initial_member_ids(MIN_INITIAL_MEMBERS, MAX_INITIAL_MEMBERS)
        .prop_flat_map(|initial_members| {
            // An intermediate tuple strategy
            (
                arb_learner_id(),
                Just(initial_members.clone()),
                arb_config(),
                Just(Uuid::new_v4().into()),
                arb_learn_sequence(initial_members.clone()),
            )
        })
        .prop_map(
            |(sut_id, initial_members, config, rack_uuid, learn_sequence)| {
                TestInput {
                    sut_id,
                    initial_members,
                    config,
                    rack_uuid,
                    learn_sequence,
                }
            },
        )
}

pub struct TestState {
    // The Fsm under test
    sut: Fsm,

    // The generated configuration
    config: Config,

    // Any peers connected to the SUT Fsm
    connected_peers: BTreeSet<Baseboard>,

    // The current time at the SUT Fsm
    now: Instant,

    // Rack secret threshold
    threshold: usize,

    // Packages that we pretend were generated by a rack coordinator
    pkgs: Vec<SharePkg>,
}

impl TestState {
    pub fn new(
        sut_id: Baseboard,
        initial_members: BTreeSet<Baseboard>,
        config: Config,
        pkgs: Vec<SharePkg>,
    ) -> TestState {
        let threshold = initial_members.len() / 2 + 1;
        TestState {
            sut: Fsm::new_uninitialized(sut_id, config),
            config,
            connected_peers: BTreeSet::new(),
            now: Instant::now(),
            threshold,
            pkgs,
        }
    }

    pub fn learn_share_pkg(&mut self, actions: Vec<LearnAction>) {
        // First send a `Learn` request to the SUT to start the process
        assert!(self.sut.init_learner(self.now).is_ok());

        // Check that the state of the SUT is correct when no peers are connected
        self.check_learning_state();

        for action in actions {
            match action {
                LearnAction::Timeout(peer_id) => {
                    self.trigger_learn_timeout(peer_id);
                }
                LearnAction::CannotSpareAShare(peer_id) => {
                    self.cannot_spare_a_share(peer_id);
                }
                LearnAction::Success(peer_id) => self.learn_success(peer_id),
            }
        }
    }

    fn check_learning_state(&mut self) {
        assert_eq!(self.sut.state(), &State::Learning);
        // We aren't connected to any peers, so no messages should have been sent yet
        assert!(self.sut.drain_envelopes().next().is_none());
    }

    // The number of ticks required to trigger a `learn` timeout
    fn ticks_until_learn_timeout(&self) -> usize {
        usize::try_from(
            (self.config.learn_timeout.as_millis() / TICK_TIMEOUT.as_millis())
                + 1,
        )
        .unwrap()
    }

    // Firts connect to `peer_id` so that a learn request is issued. Then
    // successfully ack it and ensure the state transition to `State::Learned`
    // occurs.
    fn learn_success(&mut self, peer_id: Baseboard) {
        self.disconnect_all_peers_and_clear_pending_learn_request();
        let request_id =
            self.connect_and_expect_a_learn_request(peer_id.clone());

        // Let's just hand out the first decrypted share after we reconstruct the rack
        // secret
        let mut shares = vec![];
        for i in 0..self.threshold {
            shares.push(self.pkgs[i].common.share.clone());
        }
        let rack_secret = RackSecret::combine_shares(&shares).unwrap();
        let first_pkg = self.pkgs.first().unwrap();
        // Decrypt and discover the share to distributed
        let share =
            first_pkg.decrypt_shares(&rack_secret).unwrap().expose_secret()[0]
                .clone();

        let mut common = first_pkg.common.clone();
        common.share = share;

        let learned_pkg = LearnedSharePkg { common };

        let rsp = Response {
            request_id,
            type_: ResponseType::LearnPkg(learned_pkg.clone()),
        }
        .into();
        let output = self.sut.handle_msg(self.now, peer_id, rsp);
        assert_eq!(output, Ok(Some(ApiOutput::LearningCompleted)));
        assert!(self.sut.drain_envelopes().next().is_none());
        assert_eq!(self.sut.state(), &State::Learned { pkg: learned_pkg });
    }

    // We can only guarantee that a `Learn` request for a peer will
    // be sent if it is the only connected peer. We guaranteed this by
    // disconnecting all peers and then ticking through a timeout so that no
    // outstanding request remains.
    fn disconnect_all_peers_and_clear_pending_learn_request(&mut self) {
        for peer in &self.connected_peers {
            self.sut.on_disconnected(&peer);
        }
        self.connected_peers = BTreeSet::new();
        for _ in 0..self.ticks_until_learn_timeout() {
            self.now += TICK_TIMEOUT;
            assert!(self.sut.tick(self.now).is_ok());
            assert!(self.sut.drain_envelopes().next().is_none());
        }
    }

    // Connect to trigger a learn request, then drain envelopes and ensure
    // one is sent. Return the request_id;
    fn connect_and_expect_a_learn_request(
        &mut self,
        peer_id: Baseboard,
    ) -> Uuid {
        self.connected_peers.insert(peer_id.clone());
        assert!(self.sut.on_connected(self.now, peer_id.clone()).is_ok());
        let mut iter = self.sut.drain_envelopes();
        let envelope = iter.next().unwrap();
        assert_matches!(envelope,
        Envelope {
            to,
            msg: Msg::Req(Request {  type_:  RequestType::Learn,  ..})
        } if to == peer_id
        );
        assert!(iter.next().is_none());
        envelope.msg.request_id()
    }

    fn connect_and_expect_no_messages(&mut self, peer_id: Baseboard) {
        self.connected_peers.insert(peer_id.clone());
        assert!(self.sut.on_connected(self.now, peer_id.clone()).is_ok());
        assert!(self.sut.drain_envelopes().next().is_none());
    }

    // First connect to peer_id so that a `Learn` request is issued. Then mock an
    // error response.
    //
    // The error is reported to the Fsm API output for logging, but no new learn
    // request is sent, as that optimization is not implemented. Instead another
    // learn request will be sent on the next timeout. We expect learn timeouts
    // to be on the order of 5s, so this does not seem unreasonable in order to
    // keep the code simple.
    fn cannot_spare_a_share(&mut self, peer_id: Baseboard) {
        self.disconnect_all_peers_and_clear_pending_learn_request();
        let expected_request_id =
            self.connect_and_expect_a_learn_request(peer_id.clone());

        // Respond with an error
        let rsp = Response {
            request_id: expected_request_id,
            type_: ResponseType::Error(MsgError::CannotSpareAShare),
        }
        .into();
        let output = self.sut.handle_msg(self.now, peer_id.clone(), rsp);
        assert_matches!(
            output,
            Err(ApiError::ErrorResponseReceived {
                from,
                state,
                request_id,
                error
            }) => {
                assert_eq!(from, peer_id);
                assert_eq!(state, "learning");
                assert_eq!(request_id, expected_request_id);
                assert_eq!(error, MsgError::CannotSpareAShare)
        });

        self.disconnect_all_peers_and_clear_pending_learn_request();
    }

    // First connect to peer_id so that a `Learn` request is issued. Then call
    // `Fsm::tick` enough times that the learner times out and moves onto the
    // next peer.
    fn trigger_learn_timeout(&mut self, peer_id: Baseboard) {
        // There should be a single learn request destined for `peer_id` if this
        // is the first connection when the SUT is in `State::Learning`
        if self.connected_peers.is_empty() {
            let _request_id = self.connect_and_expect_a_learn_request(peer_id);
        } else {
            self.connect_and_expect_no_messages(peer_id);
        }

        // We have at least one connected peer, so on timeout another `Learn`
        // message will be sent. Before timeout, though no messages will be
        // sent.
        for _ in 0..self.ticks_until_learn_timeout() - 1 {
            self.now += TICK_TIMEOUT;
            assert!(self.sut.tick(self.now).is_ok());
            assert!(self.sut.drain_envelopes().next().is_none());
        }
        // Trigger the timeout
        self.now += TICK_TIMEOUT;
        assert!(self.sut.tick(self.now).is_ok());
        let mut iter = self.sut.drain_envelopes();
        assert_matches!(iter.next().unwrap(),
        Envelope {
            to,
            msg: Msg::Req(Request {  type_:  RequestType::Learn,  ..})
        } if self.connected_peers.contains(&to)
        );
    }
}

proptest! {
    #![proptest_config(
        ProptestConfig {max_shrink_iters: 100000, ..ProptestConfig::default()})]
    #[test]
    fn run(input in arb_test_input()) {

        let pkgs = create_pkgs(input.rack_uuid.0, input.initial_members.clone())
            .unwrap()
            .expose_secret()
            .clone();

        let mut state = TestState::new(
            input.sut_id,
            input.initial_members,
            input.config,
            pkgs
        );

        // Complete the learn sequence until the learner has received its
        // `LearnedSharePkg`
        state.learn_share_pkg(input.learn_sequence);

    }
}

fn main() {
    run();
}
