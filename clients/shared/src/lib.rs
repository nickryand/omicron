// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

//! Workspace-wide `reqwest::Client`s.
//!
//! Creating a new `reqwest::Client` is surprisingly expensive (it creates
//! the TLS connector, which requires that OpenSSL read and parse the trusted
//! CA certificates from disk), but cloning an existing client is cheap (it
//! uses `Arc` internally).
//!
//! The functions in this crate create a `reqwest::Client` once and store it in
//! a static variable, then return a clone of that client.

#![allow(clippy::disallowed_methods)]

use reqwest::Client;
use reqwest::Result;
use std::sync::OnceLock;

macro_rules! try_impl {
    ($init:expr) => {{
        static CLIENT: OnceLock<Client> = OnceLock::new();

        match CLIENT.get() {
            Some(client) => return Ok(client.clone()),
            None => {
                let client = $init?;
                Ok(CLIENT.get_or_init(|| client).clone())
            }
        }
    }};
}

/// Return a `Client` with 15 second timeouts (the default for client libraries
/// generated by Progenitor).
///
/// Panics if the client was not already built and failed to build.
#[track_caller]
pub fn new() -> Client {
    try_new().unwrap()
}

/// Return a `Client` with 15 second timeouts (the default for client libraries
/// generated by Progenitor).
///
/// Returns an error if the client was not already built and failed to build.
pub fn try_new() -> Result<Client> {
    try_timeout::<15>()
}

/// Return a `Client` with a custom timeout in `TIMEOUT` seconds.
///
/// Panics if the client was not already built and failed to build.
#[track_caller]
pub fn timeout<const TIMEOUT: u64>() -> Client {
    try_timeout::<TIMEOUT>().unwrap()
}

/// Return a `Client` with a custom timeout in `TIMEOUT` seconds.
///
/// Returns an error if the client was not already built and failed to build.
pub fn try_timeout<const TIMEOUT: u64>() -> Result<Client> {
    try_impl!(Client::builder()
        .connect_timeout(std::time::Duration::from_secs(TIMEOUT))
        .timeout(std::time::Duration::from_secs(TIMEOUT))
        .build())
}

/// Return a default `Client` with no timeout.
///
/// Panics if the client was not already built and failed to build.
#[track_caller]
pub fn no_timeout() -> Client {
    try_no_timeout().unwrap()
}

/// Return a default `Client` with no timeout.
///
/// Returns an error if the client was not already built and failed to build.
#[track_caller]
pub fn try_no_timeout() -> Result<Client> {
    try_impl!(Client::builder().build())
}
